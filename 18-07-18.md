2018-07-18 (수)

# 학습 목표

## 7월 3-4주차 목표: 뱅크샐러드 프로젝트 구조에 익숙해지기

- ### 뱅크샐러드 프로젝트 구조에 대한 이해

  - RxJava
  - 아키텍쳐
  - 코드 컨벤션
  - 코드 스타일

- ### 안드로이드 이슈 학습

  - 2018 Google i/o
  - Android weekly

# 학습 내용

- ## Clean Architecture

  뱅크샐러드에서 사용하는 아키텍쳐 구조가 완벽한 클린 아키텍쳐는 아니다. 따라서 클린 아키텍쳐를 구현했다 말하는 다른 안드로이드 프로젝트들을 참고하고, 비교 분석하며 구조에 대해 학습했다.

  - 다른 예제들을 찾아보니 안드로이드에서는 보통 Domain과 Entity를 혼용하여 사용하는 경우가 많았다.
  - Repository는 Data에만 존재했다.
    - 뱅크샐러드는 domain, data에 존재한다.
    - domain에 있는 repository의 정의를 "usecase들이 모여 있는 곳" 정도로 정리해도 되는지 궁금하고, repository로 묶는 기준이 무엇인지 궁금하다.
    - data에 있는 repository는 domain에 있는 repository를 상속받아서, "데이터 통신"에 관련된 저장소로 사용하는 것으로 이해하는 게 맞는지?
  - 프레젠테이션 레이어의 BaseActivity에 프레젠터와 뷰의 관계를 제너릭으로 선언해 놓은 이유는, 강제적으로 정의해 놓도록 하기 위함인지?
    - 맞다.

  

  **Todo App**

  - App
    - Data
      - Repository
    - 각 기능
      - Domain
        - model
        - usecase (repository 끌어와서 사용)
      - Presentation

  

  **Banksalad**

  - Entity
  - Domain
    - Usecase - Repository 끌어와서 사용
    - Repository - usecase들이 모여 있는 곳??? repository로 묶는 기준...?
  - App
    - Presentation - repository에 정의돼 있는 함수들의 실질적인 구현
    - Data
      - repository - 도메인의 repository를 상속받아서, 실제로 구현. 데이터 통신과 관련된 저장소로 사용?

  

  ### 뱅크샐러드 앱은 왜 완벽한 클린 아키텍쳐가 아닌가?

  - 밥 아조씨의 클린 아키텍쳐 레이어는 네 단계이다. UI, Presenter, Use case, Entity.

  - 하지만 뱅크샐러드는 presentation 단에서 UI(view)와 presenter를 모두 구현하는 것으로 되어 있기 때문?
  - 이거 진짜 감이 안 와서 속상하다 ㅠ ㅠ

  ### boilerplate 프로젝트 구조에는 왜 entity가 따로 빠져 있지 않을까?

  - data > model 내에 BufferooEntity가 있다. 왜지? ㅠㅠ
  - 클린 아키텍쳐에서 Data의 위치... 어떻게 봐야 하는지 여전히 잘... 모르겠다...

  ### 안드로이드에서 인터페이스로 정의해야 하는 것...

  - MVP 패턴에서 테스트 코드를 작성할 때, 프레젠터와 뷰는 서로를 모르고 있는 상태이기 때문에 presenter 코드에 관련된 테스트 코드를 작성할 때 뷰에 접근을 하는 부분이 포함되면 테스트가 되지 않았다. 따라서 뷰의 인터페이스를 mock으로 만들어 접근을 했다.
  - 엔티티는 도메인을 모른다. 도메인은 엔티티를 안다. 도메인에서 테스트 코드를 작성할 때 엔티티에 관련된 부분을 검증해야 한다면, 엔티티의 인터페이스를 mock으로 만들어서 접근해야 한다.
    - 그렇다면 인터페이스로 정의해 놓는 것은 테스트 코드, 규약을 정해 놓는 것으로 강제, 가독성... 정도의 이유가 있을 것 같은데, 외의 또 다른 기능이 있는지?

  ### 모델? Mapper? 데이터를 애써 분리해 놓고 왜 다시 변환하는 과정이 필요????

  - **이 독립성에 도달 할 수 있도록 각 계층이 자체 데이터 모델을 사용한다는 점을 언급 할 가치가 있습니다.** (코드를 보면 데이터 변환을 수행하기 위해 데이터 매퍼(mapper)가 필요하다는 것을 알 수 있습니다. 데이터 변환을 수행하려면 비용(price)을 지불해야 하므로 이를 원치 않는다면 전체 응용 프로그램에서 동일한 모델을 사용하셔도 됩니다.)
    - 동일한 모델을 사용한다 = 엔티티로 빼 놓는다는 말인가?????

  

  ## Calculator 리팩토링

  - 0 set text 잘못 하던 것 수정
  - resultMode일 때 사칙연산 버튼에서 동작 안 하던 것 수정
  - reset 버튼 클릭 이벤트 수정
  - 필드 가시성 private으로 수정
  - 맨 처음 계산하는 값인지 확인하는 boolean 변수 삭제하고 calculateMode가 입력되어 있지 않은지로 수정

  ## Calculator 코드 리뷰

  - Q. 동작을 검증해야 하는 함수가 각 사칙연산마다 겹치는데, 개선 방법이 무엇일지?
    - A. 어느 사칙 연산인지만 매개변수로 받아오도록 하고, 공통된 부분을 함수로 뺀다.
    - A2. ENUM 클래스 사용.

  https://academy.realm.io/kr/posts/clean-architecture-in-android/

  # 레이니스트에서는 왜 클린 아키텍쳐를 사용할까?

  변화무쌍한 서비스의 코드를 효율적으로 관리하기 위해. 변화가 일어나는 곳에서만 코드의 변화가 일어나도록, 코드를 잘 분리해 놓기 위해서. 예를 들자면, DB 코드는 액티비티 코드에 영향을 주지 않도록 코드를 잘 분리해 놓아서 DB에서 변화가 일어나면 DB 코드만 수정하고, 액티비티는 수정을 하지 않아도 되게 하기 위한 방법으로 클린 아키텍쳐를 사용.

  # 그렇다면 코드를 어떻게 잘 분리할까?

  코드가 본질에 맞게 설계돼 있어야 한다. DB 테이블은 레이아웃을 구성하는 곳에서 사용되지 않도록 분리하는 것처럼, 각각의 본질이 다른 본질에 영향을 끼치지 않게.

  데이터의 본질을 정의할 때 어떤 데이터베이스에 저장될지, 어떤 뷰에서 보일지 고민하면서 정의하게 되면 의존성이 생기기 마련이다. Clean Architecture은 이러한 고민을 하지 않게 하고 오로지 데이터의 순수한 본질 자체를 정의해 놓음으로써 의존성을 떼 놓는다.

  # Clean Architecture

  - UI, DB, 외부적 설정 등에 각각 독립적인 구조를 적용
  - 프레임워크에 의존적이지 않은 구조를 짤 수 있음
  - 테스트가 가능한 코드를 짤 수 있음

  # Android Clean Architecture

  - ## Presentation

    - 가장 바깥 쪽으로, 사용자에게 보여지는 로직을 결정하는 레이어.
    - 의존성이 가장 높음.
    - repository에 정의돼 있는 함수의 실질적인 구현.
    - 레이니스트에서는 BaseActivity에 프레젠터와 뷰의 관계를 강제적으로 정의해 놓도록 하고 이를 상속받아 사용함으로 타입을 체크함.
      - Q. 왜? 뭐 하는 액티비티인지, 어떤 프레젠터와 뷰로 이루어져 있는지 명확히 하기 위함인가?
    - fun ~~~ { getUser.apply { ... } }

  - ## Data

    - 네트워크를 포함한 데이터를 가져오는 레이어.
    - repository에 정의돼 있는 함수의 실질적인 구현.

  - ## Domain

    - 사용자의 유즈 케이스로 분리되는 레이어. '소비 내역을 가져온다', '내 정보를 불러온다'... 등의 사용자가 하는 행동의 정의.
    - 안드로이드 모듈이 아닌, 순수한 Java(Kotlin) 모듈
    - 레이니스트에서는, 도메인 내에 usecase와 repository를 분리
      - repository
        - 하나의 엔티티에 대한 모든 유즈케이스의 함수들이 저장돼 있는 곳
          - Q. 이렇게 보면 되는 거 맞는지?
        - UserRepository > changeUserName, getUser...
      - usecase
        - 사용자의 동작 정의
        - ChangeUserName

  - ## Entity

    - 사용자의 머릿속 본질의 개념 단위를 정의하는 레이어.
    - 가장 의존성이 낮음.
    - 안드로이드 모듈이 아닌, 순수한 Java(Kotlin) 모듈
      - 다른 언어로 짜든 그 형태가 유지될 수 있도록
    - User

  # Clean Architecture in BankSalad

  1. entity
     - ex) User
  2. domain
     - repositories
       - ex) UserRepository > changeUserName, getUser, dropUser...
     - usecases
       - ex) DropUser
  3. app
     - presentation
       - ex) fun ~~~ { getUser.apply { ... } }
     - data
       - ex) fun dropUser { Realm에서 user을 drop하는 과정... }